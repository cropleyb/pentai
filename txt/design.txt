Classes
-------
detect 5 in a row from substrip?

GameState - should mark a particular state of the board - LengthCounter, captures (W/B)
Board - part of a game state object, just the pieces on the board, no knowledge of pente
Rules - board size, capture rules, first move constraints
Game - should know players, rules, how to make moves, should operate on the GameState object
Pos  - a position on the board
Player - Base for human and computer players
 - name
AIPlayer - Calculates utility from State. # knows about ABState, ABGame, sets them up from Board class
IBoardDisplay, KVBoardDisplay, TxtBoardDisplay (,curses?), NullBoardDisplay
Rules - board size, 5 in a row, etc.

ABState - state used by alpha-beta search code
ABState must be notified of changes to the wrapped GameState, so it can update the 
substrips - similar to the gui; it only needs to be told about adding and removing stones, and doesn't need
it's own Board instance; use the same code for both.
ABGame - game used by alpha-beta search code

AB code has a cutoff test, which can be used by the GUI



GameUI
(two subclasses, kivy and txt)

GameState.make_move()
  changes it.
GameState.__init__(parent)
  just copies it

'''
BoardGUI - contains: board, players, current state, potential state
  try_move(move) - throws IllegalMoveException, returns set of captured stones
    triggered from on onTouchDown and onTouchMove
  make_move() - makes the move currently selected: sets current_state to
                potential state. Detects end of game
    triggered from on onTouchUp and confirm
  undo()
'''
PieceGUI - contains position
PanelGUI?

human versus computer player scenario
txt human turn:
game move finished by computer triggers get_next_move()
game calls the current player (with the interface object?) to get the next move
for a human move, it calls back to the game to get a move. The game calls the interface object to request another move. The main loop checks for a flag that is set when a valid move has been entered (typed in). The game object is given the move, and updates the state using the rules object.
Changes to the game state (board, captures) are sent to the GameGUI
 object (in this case a TxtGameGUI instance) and flush() called to trigger
 a redraw.

txt computer turn

text_gui_main.py creates the Game, Players and contains the game turn loop

kivy_gui_main.py creates the Game, Players and App

player interface:
player name property

AI player: prompt_for_action() - Calls AB search in a separate thread,
           which triggers GUI perform action when it is finished.
           calls the GUI to display "<Px> is thinking"
GUI places this in a queue to be accessed by GUI: enqueue_action
GUI perform() calls
    GUI Action get_action() - fetches the action from the queue then calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action, and sets a timer to call
         perform again if there is anything in the queue

For human:
Human: prompt_for_action() calls the GUI to display "Your move <Py>"
on_touch_up
    Creates the MoveAction and puts it in the queue, then triggers Gui perform
GUI perform() calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action

game gui interface
make move?
- Place stone (pos, colour)
- Remove stone (pos)
- add captured stone
- remove captured stone (for undo/rewind)
- draw board / flush() (pass for Kivy)
  - show who is to move (though this isn't a method of the class)
- get a move


PriorityFilter

                    Max Depth
4s                  10
capture threats     10
3s                   6
2s                   2
nearby last 2 moves  1

TODO?: Do a 1 level search first, sort by utility, then use this search order
       for a deep (but narrower) search.
The deeper the search, the narrower.
The utility function needs to feed the search filter candidate moves,
classified by priority and who is to move at that depth level of the
search tree.

Problem
There may be 2 or more length 3 extending moves for black at pos (6,4),
from different directions. We only need to iterate over it once, but
when we remove it from one direction, that shouldn't remove it from the other
direction. OTOH, if someone plays on (6,4), both should be removed.
Hopefully this would be fixed by keeping a count of the times it has been added.
(dict)

Problem: who knows who?

ABGame
 has
AIPlayer
ABState
  has a
PriorityFilter
  is a
CandidateAccumulator - it would be nice if the interface to this used pos
DirectionStrip - for index to pos conversion
Capture matching - by index
Threat matching - by index, same tech as for Capture matching
Length Lookup table - Singleton?
BoardStrip: occs for a strip

Prob: observers
currently board observers
2 types of observers: Current game observers and AI search observers
AI (ABState) needs to know about all changes in a search
GUI (PenteScreen) needs to know about all changes to the real game,
and maybe to changes in a search
Game.current_state should be observed by the GUI. - through Game or GS?
GameStates in the search tree should be observed by the AI.
It would be nice to be able to watch the search in progress,
maybe to a fixed depth (even 1) i.e. GUI observing AI search states -
this would need capture ghosts to be turned off or made reversible

Different types of observation:
add/remove occ; before/after
captures
finished move
game won

GA for AI config
GA params:
    max search depth
    capture base level
    capture value scaling
    max moves per depth level

AB state operates on UtilityData, knows about PF, UC, US, should primarily
be a bridge to the Alpha Beta search code.
AB game
    1 per AI player
PriorityFilter:
    1 created per AB state?
    max search depth
    max moves per depth level
    min priority
UtilityData
    1 created per AB state
GAGenome
    1 per AI player
AIPlayer - translate the GAGenome to the other AI classes? Only in setup?
UtilityCalculator class
    1 per AI player
    capture base level
    capture value scaling
    line length value scaling

Each generation:
Play each AI against each of the others twice - n squared * 2
6 players -> 72 games per gen?!
sort best to worst
New pool: 3 best + mate each pair
Mutate 1 aspect of each of the new ones?

Problem: Playing badly once a loss is detected
All forceable losses are considered equal.
Solution: don't use infinity? Only partial solution.
AB alg. looks for best move by each player; if there is a forceable win,
all moves are considered equally futile. We want to move so that there are
less winning choices.
Alter AB so max node chooses moves with less losing options

Where does the game filename belong?
- game.py - needs to persist due to autosave
- pente_screen.py - creates the autosave filename
- pente.kv LoadScreen - calls app in kivy_gui_main
- kivy_gui_main.py
- setup screen

Evaluate internal nodes:
those that are "close" need more searching, those that aren't, don't
close: divide big score by little score, abs() < 100 -> close?
e.g. start with width 20
for nodes that are "close", evaluate their children with width 19
for nodes that are not "close", evaluate their children with width 10

Budget searcher
---------------
Allocate a number of leaf nodes to be searched to the root searcher.
This is split (evenly?) into the child nodes.
Only some priority levels need be searched, depending on the threat priority
Capture and line threats are treated independantly at this stage:
Threatening 5 - only need to look at that one node, it's a win
Threatening 5 captures - only need to look at that one node, it's a win
Threatened 5 - block it or capture (part of it*), or we lose
Threatening double 4 (single point) - look at that one node first,
                                      it's probably a win
Threatening 4 - look at that one node first, it is forcing
Threatened double 4 (single point) - look at that one node last?**,
                                      it's probably a loss
Threatened 4 - look at those nodes first, we could be forced


*Do we need to detect/precalculate which moves can capture a given point?
**We may not need lots of search through this node except for this node
and if we search it last we can use more nodes to do it

Where should the number of captures live?
GameState
Needed by:
ABState
UtilityStats
UtilityCalculator
BudgetSearcher

openings book
-------------
each position has 4 rotations, and 2 flips of each of these, for a total of 8 equivalents
Only store the version of the position with the lowest value.
1 rotations is easy: look at N or E direction_strips.
The flip is also easy: reverse the order of the board strips in a direction_strip
The last flip is tricky - reversing each of the board strip bit string numbers

Each position has one (or more?) recommended move.

Extracting opening moves from games:
Generate and/or download lots of top level games.
Write a tool to add a game to the opening "database".
pickled dictionary - canonical position to options, each with a count of wins and losses for black.

Opening filter class
--------------------
 - chooses one of the moves that is favorable for the current player, weighted by the wins and losses, then converts this move back to the non-canonical position (by reversing the steps taken to make the position canonical).

- There may only be one sensible move

- ratio of wins/losses for the search player
- more weighting for better players
- less games -> more chance of falling through to standard priority filter

jelly bean approach?:
for each game (==move):
	give the move a score scaled by the rating of the player of that side

if that move won, add 1 to the move's numerator
if that move lost, add 1 to the move's denominator

1 point for falling through to PF.

Add up each move and divide (wins:0 -> 0) - this gives the "proportion"
Use random(total) to determine which option is chosen

Fall through to PF: should this filter out the existing options?
Yes: More variety, but may force bad moves - implement later for blindness option
No: May just choose a bad option anyway. There may not be a good option.

Openings library
----------------
generate with lots of games
rating of computer opponents determined by the filter process, based on depth, width. (save data in the player)
rating of human opponents calculated (by filter process, later)

rules types: opening filter can choose moves from other DBs if the position
is not found in the original rule set.
1st: Standard rules / Tournament rules / Freestyle rules
2nd: Five-In-A-Row rules
3rd: No Capture rules

computer opponents
------------------
depth
speed
width chokes
blindness (5% intervals)
openings book on/off

Store AI players in DB - per game or globally? or both?
Store their genomes - turn the run_ai code into an ai_factory.
- look up the name of the player in the DB, get the genome

AIPlayer
Genome
AIFactory
Game
PreservedGame init from Game instance, any need for reverse transform? Replay?
PreservedGameDB
AllPreservedGames
OpeningsManager orders the search through the PositionsDBs, converts games to
  openings
PositionsDB - one file/instance per rule type
AIPlayerDB - just stores the Genomes
HumanPlayerDB

evaluator
---------
Need to see what the score is for any screen position, updated with each move.
  Need:
UtilityCalculator
UtilityStats
Share GameState
  Don't want:
AB Game, State, PriorityFilter, AI Player

Transposition table
-------------------
dict from position to utility score
position key should include captured info, and EDirectionStrips
Only generate these from depth 2 to max depth - n (tweak)
size per pos should be board size * 64 bits + 64 bits for captures
 + 128 bits for utility
16 * 64 = 1 kbit
intercept ABGame's utility, terminal check,
  alpha_beta "return v" statements need to call game.save_utility
ABGame.terminal needs to look up the TT; if it is cached, save to ABState and
return true
utility needs to look up for a saved value
ABGame.save_utility

Game Manager
------------
- recent/unfinished games: "unfinished" key
- finished games list? do we need this?
- dispense game unique ids? "last" a key to this. for the val, inc rules
- find games in appropriate DB (filename calc from rules)
- create games?
- list of games per player? Later?
- remove game from DB? Later.

DB Manager?
-----------

DB Classes
----------
Game (?)
GameMgr - creates and stores games/preserved games,
		   allocates unique ids. Owns Games DBs,
		   owns recent games DB (just the keys to the games)
		   Uses the PlayersMgr to reconstitute players
PreservedGame - Converts to/from game/preserved game
OpeningsMgr -> contains several Position DBs? Converts a game or
   PreservedGame to positions
OpeningsFilter - uses the results of the OpeningsDB (PositionsDBs per rules)
AIFactory - Converts between Genome and AIPlayer (hidden inside PlayerMgr?)
Genome - Preservable form of AIPlayer
PlayerMgr - Stores the Players HumanPlayers directly,
           AIPlayer as Genomes via AIFactory
AIPlayer(?)
DatabaseMgr? Container for all these singletons?

Rename OpeningsFilter to openings_mover
Rename OpeningsMgr to openings_library
save the games_mgr in run_ai to save the game_id to game mapping
Generate some data for the OpeningsMgr in run_ai.py
OpeningsMgr needs to store things persistently. done
OpeningsDB -> OpeningsMgr done
PlayerDB -> PlayersMgr done
game_manager -> GamesMgr done
Convert the GameMgr player_mgr param from str to obj. done
Split Genome out of AIFactory. -> AIGenome. done

DB stories
----------
autosave game to DB
list recent/unfinished games
load game from DB from GUI
replay old game (but no overwrite)
choose/change player (name) from list
load player
save player
edit player
UI for turning openings book on/off
add game to openings DB from run AI (done)
use openings DB to select a move (done)

Games
game_id is a unique id, but it isn't enough to look up the DB files
that are for getting the preserved (and then unpreserved) games back.
Either:
	Use a key of (rules key, id)
	Have another persistent dict for id to rules key for unpacking.
If we find a game in the openings db, we have the rules type already
so if we can optionally pass that in to the unpacking function then
we save a lookup. Actually we can get the DB for all the games unpacking
once since they all use the same one for a particular active game.

Openings book search integration
--------------------------------
We don't need to follow the filter pattern because it isn't going into
the search algorithm.


reconstitution of games and players for use by openings move selection.
perhaps we only need the preserved games and ai genomes?
game_mgr.get_preserved?
I'd rather keep them as implementation details for storage only, but?
or if we have a singleton for each of these managers then it isn't a big problem
to get all the extra info.
Singleton base class?

Circular dependency:

players mgr -> ai_factory -> ai_player -> games_mgr -> players_mgr

the link from ai_player to games_mgr seems least important

another one:
ai_factory -> games_mgr directly

so here the line from games_mgr to players_mgr seems weakest

Hmmm. If the imports are of the form:
    import module
rather than:
    from module import *
Then these circular dependencies aren't a problem because they
don't share a namespace.

Player Database
---------------
the player keys should be uids as for games - store these in games,
allocate from players_mgr
key -> genome in persistent dict.
How do we avoid duplicate players?
- Additional lookup by name (built at runtime)
- Additional lookup by genome (runtime linear search)
- Generated "names" for AIs? Hmmm.
- Choose players

Screen coordination & DBs
-------------------------
App - 
Menu page - Choose: New game, Load game (unfinished), Review, Edit players
    # edit openings?
Load Screen - Should select a Game from the GamesMgr
Player Edit Screen - Create player, type: human/computer(eventually online),
        rating, speed, openings use
New Game Screen - Select players (dropdown), rules type, size, time controls
Setup Screen - disabled for production version (keyboard only?),
        but use New Game Screen (rename)
Options Screen - music, sound, + as per now. (persistent?)
Games Screen - Same as Load Screen?
Pente Screen - Where it is played :)
BoardGUI - upper PenteScreen
ControlsGUI - lower panel of PenteScreen
Demo Screen - wrapper around PenteScreen

DBs, needed by:
Games: load, pente screen after win or on exit, game passed in as opened
Players: player edit, new game. only edit ai genomes?
Openings: pente screen only

Where to start? Menu/Start screen...
Save game to DB on leave game call from pente screen (to menu)?
On game finished? Automatic callback to game state observer? Both of these.
Used observers for both single move and end of game.
load game from games mgr - need to know which game -> GUI or hardcode for now.
create a new game from games mgr

keyboard handling? No such thing in apps, so must be supported another way
as well

Utility Function
----------------
Subtraction mode versus Divide mode - for calculating an overall value
for the position from scores for each side.
Sub mode seems to produce a better win rate, but gives skewed results
occasionally due to favouring bigger own scores
Div mode has a much lower win rate, why?

We want a UF that consistently ranks positions from best to worst
Our Score = OS; Their Score = TS
Sub: OS - TS Add lots of small stuff to both sides -> cancels
Div: OS / TS Add lots of small stuff to both sides -> no cancel

Do we need to encode the "initiative" into the utility score?
i.e. player with max length, or the turn if equal and no takes
How much is it worth?

-> Write more direct utility tests.

Sub mode seems to work except when early in the game when it sometimes
sacrifices a capture for a 3 or so.
Compensate: ratio of pieces on the board?

----------------------
Resuming game from setup screen

game class currently stores a temp_move_number for resuming after option
changes. - does it really belong there? Should it be saved in the DB? Yeah.

----------------------
ListView for Game selection
We have a collection of unfinished games, and another of all games
We want to display them in several orders:
Date (latest or earliest)
Black Player Name (A or Z first)
White Player Name (A or Z first)
Board size
Rules type

In all cases, we want the game id to be the hidden data that is selected.

CompositeListItem for displaying columns?
/Users/cropleyb/examples/widgets/lists/list_composite.py

ListAdapter required for selection

Adjusting games via GUI
-----------------------
Setup screen / New Game screen
Should production version allow in game switching of opponents?
   - probably not.
But for me yes.
Problem: New game ids every time games settings screen is used on an existing game. Create the game then allow this screen to set it up?
ugly? change Game.__init__ to call a public setup method. Not too bad.

AI Player GUI
-------------
Spinner list should include "Create New Player" at the top or the bottom
(special player id?)
Name (spinner to select which one, double click to edit name)
Speed (1 -> 10 inverted depth?) slider?
Vision (60 - 100% in 5% increments) slider?
Use Openings Book
Advanced settings: (show advanced AI settings toggle to show)
Width (mmpdl)
Capture preference (Low, Medium, High => capture_score_base 200, 300, 400)

Demo impact
-----------
How to prevent demo from affecting DBs and other state?
- Set a demo mode for each? Ugly and ineffective.
- Deep Copy all DB classes before, restore them after? Done, works nicely

Chess Clock
-----------
Current Times: Player. Hmmm - these are not about a particular game
Historical Move Times - in or parallel to move history in Game
Game time controls - Game
Tick callback set up pente_screen, or GuiPlayer
Time intervals: from 1/s to 4/s. Smooth accel.
(.5 * (1 + remaining time/original time)) ** 2 (s)

GUI Player
----------
Split out of pente_screen - TODO
prompt_for_action() -> start timer, delegate to player
Linear speed up -> quadratic curve
calls Player.tick(time_interval)

Multiprocessing
---------------
Kivy & AI search in separate processes.
Use multiprocessing module to send and receive objects.
Protocol: GUI sends a single message to request the search, with:
- preserved game or id
Search process sends back:
- a single move, or
- an error message
If the user wants to interrupt the search, the process can be killed.
The search process should treat the databases as read-only.

Replaying timed games
---------------------
Crash:
     self.game.go_backwards_one()
   File "/Users/cropleyb/Dropbox/pente/game.py", line 168, in go_backwards_one
     self.go_to_move(self.get_move_number() - 1)
   File "/Users/cropleyb/Dropbox/pente/game.py", line 193, in go_to_move
     gs.make_move(self.move_history[i])
   File "game_state.py", line 83, in game_state.GameState.make_move (game_state.c:2842)
     raise IllegalMoveException("The game is already over")
 pente_exceptions.IllegalMoveException: The game is already over

Something is causing the game to be over before it is completely replayed.
- must be time expiry related.
The game state is reset() before being replayed.

How should it work?
Take back/Back (1 move) should undo the last move, and give that player their
time as it was when the move taken back started.

Openings book early moves problem
---------------------------------
When the openings book is used for choosing a move in the early game, it is looking at a large number of games, and is using lots of memory.

Tournament rules
----------------
Human players - prevent them from moving illegally
Computer players - prevent them from moving illegally too?
Raise exception in game/game_state.
Computer players openings mover special code?

Directory structure
-------------------
src/test
src/base
src/ai
src/db
src/gui

Persistence
-----------
For games, openings, players, misc etc.
Want something like a real DB:
  Load objects from file on demand.
  MRU Cache
Easiest to use: ZODB (i.e. migrate from PersistentDict)

Rematch
-------
Finished: Loser goes first
Unfinished:
HvC - Assume computer won, Human first
HvH, CvC - Always swap

Optional Music
--------------
/ Rain
/ Modal Podal
/ Marriage
/ Cool School
/ Sometimes
/ Permeation
/ Razorwire
/ Lunar Discovery
/ Septic
/ Six Shift
/ Y Files
/ Alien Zoo
/ Brain Food
/ Progress
/ Barbells
/ Desert Crossing
/ Direction
(had to prune a few for space)

Openings book translational symmetry
------------------------------------
9x9, 13x13, 19x19
Once a board position comes within 5 intersections of an edge, it becomes incapable of being equivalently shifted in that dimension.
Let's say that if if is past that point on both sides, it is equivalent.
|
|
|
| . . . . X
|
|
|
At least one piece is within 5 intersections of the edge -> untranslatable in x

If it is over that on both sides, we'll assume it is equivalent.
|
|
|
| . . . . . . X
|
|
|

~==

|
|
|
| . . . . . X
|
|
|

Big openings book
-----------------
1. Package openings games in zip file
2. Unzip it into data directory/openings/??
3. On start up, process a number of games, to add to the openings book.

Make sure this is only included in one of the copies of the pente directory.

Put all games in the same openings book?
9x9 - scrap? don't allow?
5 in a row - scrap?
tournament rule - filter out illegal moves on P1's second
13x13 using 19x19? Games that are too wide will not match.
Check that trans_standardise cuts them to the same size
Separate positions per move number? can't hurt? Removes need for captured stones

Does rot std followed by trans std always give a canonical position?
        Add: (0L, 0L, 0L, 0L, 0L, 2048L, 0L, 4096L, 0L, 65536L)
        Get: (0L, 0L, 0L, 0L, 0L, 2048L, 16384L, 0L, 262144L)
Must do both rot and trans before selecting the minimum or maximum as the std.

ZODB openings too big
---------------------

Cut it down to just the first N moves (8?)
Measure it
pack() helped ;)

Candidate Move Ordering
-----------------------
If a move makes two or more threats, it should be searched before another move
that makes a single threat

B 4 + W 3
B 4 + B 3 -> search this one first

For each candidate move at the current priority level,
Maintain a list of the counts of priority levels it appears in
Need to be able to traverse it with own moves before opponent moves at each level.

Why is priority filter 2 better than this?
Move new code to pf 3, try orig vs. 2
Yep, orig was better.

Interruption
------------
Due to button being pressed in pente screen: Menu, Review, Rematch (not settings as it returns to pente screen)

AI Code could be in Openings Book, Openings Mover or AB search, in the search thread.
Notify the search thread via a boolean accessor in Game (via ABGame)
If the user goes to the menu then the game should be stopped and saved
Rematch should stop and save the current game. If the game is not finished and it has a human player then it should be presumed won by the AI, or current player if there are two humans.
What is the difference between live & not interrupted?

Openings book board sizes
-------------------------
Need to filter out opening moves that are too near to the edge.
So might as well separate these structurally in the DB.

Opening book variety
--------------------
Want a mix of good moves that are chosen mainly from the same sized board positions, but from the other size(s) if necessary.
Move 3 moves need to access the rules type as well.
Can use the game id to help filter them appropriately: >100000 -> 19t
Store moves for a position in order of success? Binary search?

--- Position ----- Move ----- Game
            \          \----- Game
             \-----Move ----- Game
                       \----- Game

Choose most recent games per move? Random?

random.sample(population, k)
(for the games)
Problem: there can be LOTS of games or only one.
Use a large enough sample size e.g.: min(length(games), 60)
Instead of storing the games, store summary info?
E.g. wins, losses, average and/or max ratings (don't include draws?)
Duplicate games could be a problem, but it would save time (+space?)
Wouldn't need to store the Games or the Players either -> big win.

Store moves per position in a sorted Persistent List, ordered by position.
Then we can use random.sample to select move_games for the openings mover, and insert new moves using binary search.

Or use a persistent dict for the moves and directly sample from d.items().
Yep, done:
op_pos: OpeningPosData and OpeningMoveData classes
Now what?
OpeningsBook mods for splitting out sections for rules type and board size
Modify openings builder to create them?
Do this on a branch.

Try without ZODB compression:
with at Completed: section: 40; start game: 462: -rw-r--r--  1 cropleyb  staff  1485999 30 May 15:24 db.fs
[15:33:22.593][DEBUG][Completed: section: 40; start game: 448]
-rw-r--r--  1 cropleyb  staff  1841236 30 May 15:33 db.fs
i.e. Not much difference.

Contender: Priority Filter 3 (Fukumi search order)
B/W:[0, 10, 10] won: {'Defender': 14, 'Contender': 6} C/D avg. time: 1.30995589047
38.3828125

Killer/History heuristic research
---------------------------------
average priority of chosen move (relative to best priority)
number of moves at each priority level
% chosen moves that match the killer heuristic (1 move saved per depth level of the search)
% chosen moves that match the history heuristic (count of short circuits per move)

ZODB packing
------------
Options:
1. In the background as the process is running.
2. In the background after the process finishes, using Apple specific background code.
3. In the foreground at startup.
4. Split out read-only openings DB, pack it to another file in another thread

1:
Pros:
- Easily adaptable to Android

Cons:
- Need to get the transactions across to the packed DB

2:
Pros:
- Usually painless for the user
- Less complex logic

Cons:
- Apple specific and painful coding

option 4
--------
startup

copy existing ob_db -> ob_db_new (file copy)
load both dbs (db + ob_db)
start thread for building openings book

ob thread:
build several games into openings positions
add games played so far
commit
pack
lock access to odb
mv ob_db_new to ob_db
switch global ob_db reference
unlock access to odb

main thread:
accesses to ob_db must go through a lock
finished games must go through a Queue before being added to the ob_db

Choice stats
------------
(to attempt to optimise search width & depth)

Want:
Best value was at:
Depth v1  v2  v3  v4  v5  v6  v7  v8  v9
  1   40  30  20   5   5

And:
Relative value to best:
Depth v1  v2  v3  v4  v5  v6  v7  v8  v9
  1   

This is tricky because utility values can be -ve.
Best value can be negative.

We want to filter out moves that come later in the search order, if they are unlikely to improve the result.
e.g. (in AB search):
   if v < filter_threshold:
       stop searching this branch
(where filter_threshold is calculated with respect to the best move for this branch so far)

filter_threshold = f(best move so far, unscaled filter threshold

BV CV Ratio
 5  1   .2
 5  -1  -.2  OK

BV: Best Value
CV: Current Value
(F ** CV) / (F ** BV)

FT == EXP_BASE ** (CV - BV)
...and where EXP_BASE is a constant very slightly above 1 to reduce overflow

We want to find a value of FT that filters many bad moves out, but doesn't filter out many good moves that occur late in the ordering.

It would be nice to have a table of these:

filtered out correctly %
    
    ^
    |
    |
    |
    |
    -------------> FT

and:

wrongly filtered out %
    
    ^
    |
    |
    |
    |
    -------------> FT

and maybe even chosen utility vs. best std. dev.

There are (at least) two ways of filtering:
- relative to the current best and worst value (yeah, ok, but not perfect)
- relative to the current best and a chosen threshold
  choose the threshold using knowledge of the actual best value


