<span class="font_large"><strong><span class="font_xl">PentAI</span></strong><br />I have stopped making music for a little while, and have instead been writing a program to play the abstract strategic board game &quot;Pente&quot;. So far, it just runs on my computer, but I intend to distribute it on mobile devices as well as personal computers. I find this game to be a perfect fit for my requirements for a game: it is quick to learn (&lt; 5m), quick to play (~ 5m), and there is no luck involved, but it takes many games to learn how to play well. You can find out lots of information about Pente on the net, e.g. on <a contents="wikipedia" data-link-label="" data-link-type="" href="http://en.wikipedia.org/wiki/Pente">wikipedia</a>. This page is about how my computer program PentAI is constructed.</span><br />&nbsp;<hr /><span class="font_large"><span class="font_xl"><strong>Artificial Intelligence</strong></span><br /><strong>Position representation</strong><br />The board positions are stored as four arrays of integers,<br />one array per direction (E, SE, S, SW). Each number in the arrays represents a line across the board in that direction, and the pieces on it. Two bits are used per location, with 0 representing empty, 1 Black, 2 White and 3 is unused. This allows for rapid pattern matching for lines, captures and threats in any direction, using bitwise operations such as AND, OR, XOR and shift.<br /><br /><img class="size_l justify_center border_" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/12e726d09ff2bcebd1a849dc376063a00db75b40/original/pentai-board.png?1394320990" /><br />This position would be represented in memory as:<br />E: [0, 0, 0, 0, 2048, 1024, 6160, 0, 0, 0, 0, 0, 0]</span>
<p class="p1"><span class="font_large">SE: [0, 0, 0, 0, 0, 0, 0, 0, 16, 2048, 1024, 2048, 4096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></p>
<p class="p1"><span class="font_large">S: [0, 0, 4096, 0, 0, 9728, 4096, 0, 0, 0, 0, 0, 0]</span></p>
<p class="p1"><span class="font_large">SW: [0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 2048, 5120, 2048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br /><img class="size_m justify_center border_" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/b512b56c2391f0df2089775bd4e8eb28390d244a/medium/compass.png?1394348023" /></span></p><span class="font_large">For instance, the 2048 in the East representation is for the white piece in the fifth row up - each number represents a whole line in that direction (horizontal row in this case). 2048 represents the presence&nbsp;</span><span style="font-size: 1.4em;">of a white piece in the 6th column, with nothing else in that row:</span><br /><span class="font_large">(4 ** 5) * 2 = 2048</span><br /><span class="font_large">i.e. 2 * zero bits for each of the 5 empty points to its left, and another bit for the white coloured stone.<br /><br />For a 19x19 board, that means:&nbsp;</span><br /><span class="font_large">2 x 19 x 64 bits (horiz &amp; vert) = 2432<br />2 x 37 x 64 bits (for the diags) = 4736<br />+ a couple of bytes for capture counts and programming language overheads.<br />= Around 900 bytes per position.</span><br /><br /><span class="font_large"><strong>Line Counts</strong></span><br /><span class="font_large">There is another type of data that is used extensively by the AI player - potential line length counts.<br />The AI player counts the potential 5 in a row stretches per location, with the number of already occupied locations out of each line.<br /><img alt="" class="size_m justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/5e0f3d5cb7f06b5cd04b3c20c029258dec21340d/medium/line-counts.png?1394349154" /><br /><br />At the moment, there are several potential fives that can be extended by white playing at x.<br />Starting with the left 5, these have a current count of:<br />&nbsp; &nbsp;2 &nbsp;3 &nbsp;3 &nbsp;2 &nbsp;1<br />(the one represents the stretch from x to the right edge)<br /><br />If white placed a stone at x, it would look like this:<br /><img alt="" class="size_m justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/d3c1396b104682f3f70df16a6b76d77b164fd276/medium/line-counts-2.png?1394349824" /><br /><br />and the counts would be:<br />&nbsp; 3 &nbsp;4 &nbsp;4 &nbsp;3 &nbsp;2<br /><br />These counts are used for two things: to suggest locations as candidate moves, and to give a (utility) value to positions so they can be used in the search process.<br /><br />Since this data is required for every position in the search tree, it is maintained incrementally; every time a stone is placed on the board or taken off, these counts are adjusted.<br /><br /><strong>Symmetry</strong><br />There are 8 equivalent positions for every position, from rotations or a whole board flip.<br /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/d6096677ed4f69b7da4ddd014372f292338f54f0/small/rh.jpg?1394343287" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/59dea2ecb909d8165c30ca3ad6565102852a794a/small/rh2.jpg?1394343289" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/56dad8b28a896d67ecb4382f42e205c8a7b7ec0c/small/rh3.jpg?1394343288" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/9bada5760a77e86c2c873bc30e62e19d4a6f3d1d/small/rh4.jpg?1394343288" /><br /><br /><br /><br /><br /><br /><br /><br /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/cc37636e8c5b6aaf8978390a6812ade6be3df4d5/small/lh1.jpg?1394343318" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/c25ebe67a8e800dc510b27587b184dfc2744f851/small/lh2.jpg?1394343318" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/4f98a2cb61ad10ae44042ca0ed2d0788f4518599/small/lh3.jpg?1394343320" /><img alt="" class="size_s justify_left border_none" src="http://s3.amazonaws.com/content.sitezoogle.com/u/79199/7cac23d7b36ecd983d030daeb37e4017e322bc45/small/lh4.jpg?1394343322" /></span><br /><br /><br /><br /><br /><br /><br /><br /><span class="font_large">PentAI exploits this in its &quot;Openings Book&quot;. It does this by matching a &quot;canonical form&quot; of the current game position against a hash table of canonical forms of previously played game positions. By &quot;canonical form&quot;, I mean a representation of the game position that is common to all symmetrical equivalents of that position.<br /><br />For PentAI, I chose to use the minimum East array representation. To find the canonical representation, I iterate through the symmetrical equivalents by using a couple of flipping operations - a flip along the NE diagonal by swapping the E and S lines, and a left to right flip by reversing the order of the S array and reversing the order of the 2 bit sections of each of the numbers in the E array.<br /><br />For example, assume that the current position is as above:<br />E: [0, 0, 0, 0, 2048, 1024, 6160, 0, 0, 0, 0, 0, 0]</span><br /><span style="font-size: 1.4em;">S: [0, 0, 4096, 0, 0, 9728, 4096, 0, 0, 0, 0, 0, 0]</span><br /><br /><span class="font_large">(diagonal representations aren&#39;t required for canonisation because no amount of these flipping operations will get them into the E array)<br /><br />Then after a NE diagonal flip, we would have:<br /><br />E: [0, 0, 4096, 0, 0, 9728, 4096, 0, 0, 0, 0, 0, 0]</span><br /><span class="font_large">S: [0, 0, 0, 0, 2048, 1024, 6160, 0, 0, 0, 0, 0, 0]</span>
<p class="p1"><br /><span style="font-size: 1.4em;">Or after a L/R (= E/W) flip, we would have:</span></p>
<div><p class="p1"><span class="font_large">E: [0,</span><span style="font-size: 1.4em;">0,</span><span class="font_large">0,</span><span class="font_large">0,</span><span class="font_large">1048576,</span><span class="font_large">2097152,</span><span style="font-size: 1.4em;">135790592,</span><span class="font_large">0,</span><span class="font_large">0,</span><span class="font_large">0,</span><span class="font_large">0,</span><span class="font_large">0,</span><span style="font-size: 1.4em;">0]</span><br /><span style="font-size: 1.4em;">S: [0, 0, 0, 0, 0, 0, 4096, 9728, 0, 0, 4096, 0, 0]</span><br />&nbsp;</p>
    <p class="p1"><span style="font-size: 1.4em;">The minimum E representation out of these 3 would in this case be the original position (using Python&#39;s default array ordering):</span><br /><span class="font_large">E: [0, 0, 0, 0, 2048, 1024, 6160, 0, 0, 0, 0, 0, 0]<br /><br />(Although to calculate the real canonical representation you would need to compare all 8 symmetrical equivalents.)</span></p></div><span class="font_large"><strong>Openings Move Selection</strong><br />If the position is in the Openings Book, it can be used to suggest a good move for the current player. There can be several games that have been played that match that position, with a number of wins and losses per move from that position. PentAI usually randomly selects one of these moves based on how many games were won or lost when that move was chosen. If the openings book doesn&#39;t suggest a move then it falls through to the standard search process.<br /><br /><strong>Search</strong><br />PentAI searches the game tree for a fixed number of moves, currently with a maximum of 10 levels of depth. For each position, it searches a maximum of 9 alternatives. Leaf nodes of the search are evaluated and given a score which represents how good a position it is from the perspective of the player who is doing the search. These values are bubbled up back to candidate move level, and the best (of the worst of the best of the worst etc...) is chosen. To reduce the size of the tree searched without altering the result, the <a contents="Alpha Beta algorithm" data-link-label="" data-link-type="url" href="http://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning" target="_blank">Alpha Beta algorithm</a> is used.&nbsp;</span><br /><span class="font_large">The width of the search is 9 alternatives for the top 3 levels of the search, then it is constrained to 5 alternatives per move for subsequent levels, this seems to give a good balance.<br /><br /><strong>Candidate Positions</strong><br />Candidates are chosen from the &quot;Line Counts&quot; data described above, sorted from longest to shortest. Contributions from each direction are added together per location. This candidate selection is done for every position in the search tree except leaf nodes.<br /><br /><strong>Utility Score</strong><br />Positions are each given a value so they can be compared for relative desirability. The inputs for the utility score calculation are the number of captures by each player, and the total numbers of potential fives of each current length as described above. The longer current length lines contribute exponentially more than the shorter ones. The value of captures also increases with more captures to represent the increased likelihood of a win.<br />Positions that are won or lost are given a score of positive or negative infinity respectively, and don&#39;t need to be searched further.<br /><br /><strong>Transposition table</strong><br />Further into the game, symmetries of previously reached positions become rarer. To reduce the search effort, every position is stored in a hash table to avoid having to evaluate that position or subtree again. A single representation of the position is sufficient to use as a key, so the East strips are used. The value is the previously calculated utility score of that position. Before each move, the transposition table is cleared to allow deeper search values to replace those found earlier.</span><br />&nbsp;<hr /><span class="font_large"><span class="font_xl"><strong>Implementation</strong></span><br />PentAI is written in the <a contents="Python programming language" data-link-label="" data-link-type="url" href="http://www.python.org" target="_blank">Python programming language</a>. The user interface is written using the <a contents="Kivy library" data-link-label="" data-link-type="url" href="http://kivy.org/" target="_blank">Kivy library</a>, which provides platform independence between several mobile and standard computer platforms. (iOS, Android, OS X, Windows)<br /><br /><strong>Search Process</strong><br />The CPU intensive AI code is converted into C extension modules by <a contents="cython" data-link-label="" data-link-type="url" href="http://cython.org/" target="_blank">cython</a>.<br />To prevent the GUI from becoming unresponsive, the search is split into a separate process. This is currently spawned by the GUI each turn that a search is required, although it would be fairly easy to reuse the search process if that became necessary.<br /><br /><strong>Persistence</strong><br />Most of the data storage is done using the <a contents="PersistentDict" data-link-label="" data-link-type="url" href="http://code.activestate.com/recipes/576642-persistent-dict-with-multiple-standard-file-format/" target="_blank">PersistentDict</a> class by Raymond Hettinger. Files for this format include those for Games, Players, and Openings Positions, and are equivalent to tables in a relational database.<br /><br /><strong>Settings</strong><br />For application wide settings, the PentAI program uses the standard python config module and the kivy settings module. This automagically creates an editing screen for each of the global parameters such as sound and confirmation preferences.<br /><br /><strong>Sounds</strong><br />Most sound effects have four or more variants, and one is chosen randomly from them, except that the last sound in that category that was played is excluded.<br /><br /><strong>Playing badly</strong><br />Many people have suggested that it has to be able to play badly. Making this possible is MUCH easier than making it play well. It has been implemented by a couple of techniques:</span>
<ul>    <li><span class="font_large">Vision - a chosen percentage of candidate moves from every position are skipped.</span></li>    <li><span class="font_large">Judgement - every position evaluation is adjusted randomly; the lower the judgement value, the greater the randomness applied.</span></li></ul><span class="font_large">...or the user can simply reduce the search depth.<br /><br /><strong>Statistics</strong><br />Production code size: 7173&nbsp;lines<br />Test code size: 5068 lines<br />Unit Tests: 443, which run in around 0.42s<br />AI subsystem tests: 11 which run in 20s<br />Screens: 7<br />Transposition table hits: ~8%</span><br /><span class="font_large">Positions/s: ~1200<br />Opening move time: Effectively instant.<br />Depth 10 move time: ~35s<br />Depth 6 move time: ~3s<br /><br />I hope that was interesting and useful. Let me know if you have any more questions.</span>
