Classes
-------
detect 5 in a row from substrip?

GameState - should mark a particular state of the board - LengthCounter, captures (W/B)
Board - part of a game state object, just the pieces on the board, no knowledge of pente
Rules - board size, capture rules, first move constraints
Game - should know players, rules, how to make moves, should operate on the GameState object
Pos  - a position on the board
Player - Base for human and computer players
 - name
AIPlayer - Calculates utility from State. # knows about ABState, ABGame, sets them up from Board class
IBoardDisplay, KVBoardDisplay, TxtBoardDisplay (,curses?), NullBoardDisplay
Rules - board size, 5 in a row, etc.

ABState - state used by alpha-beta search code
ABState must be notified of changes to the wrapped GameState, so it can update the 
substrips - similar to the gui; it only needs to be told about adding and removing stones, and doesn't need
it's own Board instance; use the same code for both.
ABGame - game used by alpha-beta search code

AB code has a cutoff test, which can be used by the GUI



GameUI
(two subclasses, kivy and txt)

GameState.make_move()
  changes it.
GameState.__init__(parent)
  just copies it

'''
BoardGUI - contains: board, players, current state, potential state
  try_move(move) - throws IllegalMoveException, returns set of captured stones
    triggered from on onTouchDown and onTouchMove
  make_move() - makes the move currently selected: sets current_state to
                potential state. Detects end of game
    triggered from on onTouchUp and confirm
  undo()
'''
PieceGUI - contains position
PanelGUI?

human versus computer player scenario
txt human turn:
game move finished by computer triggers get_next_move()
game calls the current player (with the interface object?) to get the next move
for a human move, it calls back to the game to get a move. The game calls the interface object to request another move. The main loop checks for a flag that is set when a valid move has been entered (typed in). The game object is given the move, and updates the state using the rules object.
Changes to the game state (board, captures) are sent to the GameGUI
 object (in this case a TxtGameGUI instance) and flush() called to trigger
 a redraw.

txt computer turn

text_gui_main.py creates the Game, Players and contains the game turn loop

kivy_gui_main.py creates the Game, Players and App

player interface:
player name property

AI player: prompt_for_action() - Calls AB search in a separate thread,
           which triggers GUI perform action when it is finished.
           calls the GUI to display "<Px> is thinking"
GUI places this in a queue to be accessed by GUI: enqueue_action
GUI perform() calls
    GUI Action get_action() - fetches the action from the queue then calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action, and sets a timer to call
         perform again if there is anything in the queue

For human:
Human: prompt_for_action() calls the GUI to display "Your move <Py>"
on_touch_up
    Creates the MoveAction and puts it in the queue, then triggers Gui perform
GUI perform() calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action

game gui interface
make move?
- Place stone (pos, colour)
- Remove stone (pos)
- add captured stone
- remove captured stone (for undo/rewind)
- draw board / flush() (pass for Kivy)
  - show who is to move (though this isn't a method of the class)
- get a move


PriorityFilter

                    Max Depth
4s                  10
capture threats     10
3s                   6
2s                   2
nearby last 2 moves  1

TODO?: Do a 1 level search first, sort by utility, then use this search order
       for a deep (but narrower) search.
The deeper the search, the narrower.
The utility function needs to feed the search filter candidate moves,
classified by priority and who is to move at that depth level of the
search tree.

Problem
There may be 2 or more length 3 extending moves for black at pos (6,4),
from different directions. We only need to iterate over it once, but
when we remove it from one direction, that shouldn't remove it from the other
direction. OTOH, if someone plays on (6,4), both should be removed.
Hopefully this would be fixed by keeping a count of the times it has been added.
(dict)

Problem: who knows who?

ABGame
 has
AIPlayer
ABState
  has a
PriorityFilter
  is a
CandidateAccumulator - it would be nice if the interface to this used pos
DirectionStrip - for index to pos conversion
Capture matching - by index
Threat matching - by index, same tech as for Capture matching
Length Lookup table - Singleton?
BoardStrip: occs for a strip

Prob: observers
currently board observers
2 types of observers: Current game observers and AI search observers
AI (ABState) needs to know about all changes in a search
GUI (PenteScreen) needs to know about all changes to the real game,
and maybe to changes in a search
Game.current_state should be observed by the GUI. - through Game or GS?
GameStates in the search tree should be observed by the AI.
It would be nice to be able to watch the search in progress,
maybe to a fixed depth (even 1) i.e. GUI observing AI search states -
this would need capture ghosts to be turned off or made reversible

Different types of observation:
add/remove occ; before/after
captures
finished move
game won

GA for AI config
GA params:
    max search depth
    capture base level
    capture value scaling
    max moves per depth level

AB state operates on UtilityData, knows about PF, UC, US, should primarily
be a bridge to the Alpha Beta search code.
AB game
    1 per AI player
PriorityFilter:
    1 created per AB state?
    max search depth
    max moves per depth level
    min priority
UtilityData
    1 created per AB state
GAGenome
    1 per AI player
AIPlayer - translate the GAGenome to the other AI classes? Only in setup?
UtilityCalculator class
    1 per AI player
    capture base level
    capture value scaling
    line length value scaling

Each generation:
Play each AI against each of the others twice - n squared * 2
6 players -> 72 games per gen?!
sort best to worst
New pool: 3 best + mate each pair
Mutate 1 aspect of each of the new ones?

Problem: Playing badly once a loss is detected
All forceable losses are considered equal.
Solution: don't use infinity? Only partial solution.
AB alg. looks for best move by each player; if there is a forceable win,
all moves are considered equally futile. We want to move so that there are
less winning choices.
Alter AB so max node chooses moves with less losing options

Where does the game filename belong?
- game.py - needs to persist due to autosave
- pente_screen.py - creates the autosave filename
- pente.kv LoadScreen - calls app in kivy_gui_main
- kivy_gui_main.py
- setup screen

Evaluate internal nodes:
those that are "close" need more searching, those that aren't, don't
close: divide big score by little score, abs() < 100 -> close?
e.g. start with width 20
for nodes that are "close", evaluate their children with width 19
for nodes that are not "close", evaluate their children with width 10

Budget searcher
---------------
Allocate a number of leaf nodes to be searched to the root searcher.
This is split (evenly?) into the child nodes.
Only some priority levels need be searched, depending on the threat priority
Capture and line threats are treated independantly at this stage:
Threatening 5 - only need to look at that one node, it's a win
Threatening 5 captures - only need to look at that one node, it's a win
Threatened 5 - block it or capture (part of it*), or we lose
Threatening double 4 (single point) - look at that one node first,
                                      it's probably a win
Threatening 4 - look at that one node first, it is forcing
Threatened double 4 (single point) - look at that one node last?**,
                                      it's probably a loss
Threatened 4 - look at those nodes first, we could be forced


*Do we need to detect/precalculate which moves can capture a given point?
**We may not need lots of search through this node except for this node
and if we search it last we can use more nodes to do it

Where should the number of captures live?
GameState
Needed by:
ABState
UtilityStats
UtilityCalculator
BudgetSearcher

openings book
-------------
each position has 4 rotations, and 2 flips of each of these, for a total of 8 equivalents
Only store the version of the position with the lowest value.
1 rotations is easy: look at N or E direction_strips.
The flip is also easy: reverse the order of the board strips in a direction_strip
The last flip is tricky - reversing each of the board strip bit string numbers

Each position has one (or more?) recommended move.

Extracting opening moves from games:
Generate and/or download lots of top level games.
Write a tool to add a game to the opening "database".
pickled dictionary - canonical position to options, each with a count of wins and losses for black.
Opening filter class - chooses one of the moves that is favorable for the current player, weighted by the wins and losses, then converts this move back to the non-canonical position (by reversing the steps taken to make the position canonical).

computer opponents
------------------
depth
speed
width chokes
blindness (5% intervals)
openings book on/off

evaluator
---------
Need to see what the score is for any screen position, updated with each move.
  Need:
UtilityCalculator
UtilityStats
Share GameState
  Don't want:
AB Game, State, PriorityFilter, AI Player

Transposition table
-------------------
dict from position to utility score
position key should include captured info, and EDirectionStrips
Only generate these from depth 2 to max depth - n (tweak)
size per pos should be board size * 64 bits + 64 bits for captures
 + 128 bits for utility
16 * 64 = 1 kbit
intercept ABGame's utility, terminal check,
  alpha_beta "return v" statements need to call game.save_utility
ABGame.terminal needs to look up the TT; if it is cached, save to ABState and
return true
utility needs to look up for a saved value
ABGame.save_utility
