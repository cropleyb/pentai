Classes
-------
detect 5 in a row from substrip?

GameState - should mark a particular state of the board - LengthCounter, captures (W/B)
Board - part of a game state object, just the pieces on the board, no knowledge of pente
Rules - board size, capture rules, first move constraints
Game - should know players, rules, how to make moves, should operate on the GameState object
Pos  - a position on the board
Player - Base for human and computer players
 - name
AIPlayer - Calculates utility from State. # knows about ABState, ABGame, sets them up from Board class
IBoardDisplay, KVBoardDisplay, TxtBoardDisplay (,curses?), NullBoardDisplay
Rules - board size, 5 in a row, etc.

ABState - state used by alpha-beta search code
ABState must be notified of changes to the wrapped GameState, so it can update the 
substrips - similar to the gui; it only needs to be told about adding and removing stones, and doesn't need
it's own Board instance; use the same code for both.
ABGame - game used by alpha-beta search code

AB code has a cutoff test, which can be used by the GUI



GameUI
(two subclasses, kivy and txt)

GameState.make_move()
  changes it.
GameState.__init__(parent)
  just copies it

'''
BoardGUI - contains: board, players, current state, potential state
  try_move(move) - throws IllegalMoveException, returns set of captured stones
    triggered from on onTouchDown and onTouchMove
  make_move() - makes the move currently selected: sets current_state to
                potential state. Detects end of game
    triggered from on onTouchUp and confirm
  undo()
'''
PieceGUI - contains position
PanelGUI?

human versus computer player scenario
txt human turn:
game move finished by computer triggers get_next_move()
game calls the current player (with the interface object?) to get the next move
for a human move, it calls back to the game to get a move. The game calls the interface object to request another move. The main loop checks for a flag that is set when a valid move has been entered (typed in). The game object is given the move, and updates the state using the rules object.
Changes to the game state (board, captures) are sent to the GameGUI
 object (in this case a TxtGameGUI instance) and flush() called to trigger
 a redraw.

txt computer turn

text_gui_main.py creates the Game, Players and contains the game turn loop

kivy_gui_main.py creates the Game, Players and App

player interface:
player name property

AI player: prompt_for_action() - Calls AB search in a separate thread,
           which triggers GUI perform action when it is finished.
           calls the GUI to display "<Px> is thinking"
GUI places this in a queue to be accessed by GUI: enqueue_action
GUI perform() calls
    GUI Action get_action() - fetches the action from the queue then calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action, and sets a timer to call
         perform again if there is anything in the queue

For human:
Human: prompt_for_action() calls the GUI to display "Your move <Py>"
on_touch_up
    Creates the MoveAction and puts it in the queue, then triggers Gui perform
GUI perform() calls
    board.make_move
    which calls make_move_on_the_board at least once via callback
GUI perform then calls prompt_for_action

game gui interface
make move?
- Place stone (pos, colour)
- Remove stone (pos)
- add captured stone
- remove captured stone (for undo/rewind)
- draw board / flush() (pass for Kivy)
  - show who is to move (though this isn't a method of the class)
- get a move


PriorityFilter

                    Max Depth
4s                  10
capture threats     10
3s                   6
2s                   2
nearby last 2 moves  1

TODO?: Do a 1 level search first, sort by utility, then use this search order
       for a deep (but narrower) search.
The deeper the search, the narrower.
The utility function needs to feed the search filter candidate moves,
classified by priority and who is to move at that depth level of the
search tree.

Problem
There may be 2 or more length 3 extending moves for black at pos (6,4),
from different directions. We only need to iterate over it once, but
when we remove it from one direction, that shouldn't remove it from the other
direction. OTOH, if someone plays on (6,4), both should be removed.
Hopefully this would be fixed by keeping a count of the times it has been added.
(dict)

Problem: who knows who?

ABGame
 has
AIPlayer
ABState
  has a
PriorityFilter
  is a
CandidateAccumulator - it would be nice if the interface to this used pos
DirectionStrip - for index to pos conversion
Capture matching - by index
Threat matching - by index, same tech as for Capture matching
Length Lookup table - Singleton?
BoardStrip: occs for a strip

